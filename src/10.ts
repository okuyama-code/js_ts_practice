// 配列を指定したサイズで分割する関数
// T[]は任意の型の配列を表す（数値の配列[1,2,3]や文字列の配列['a','b','c']など）
// 戻り値のT[][]は「配列の配列」を表す（例：[[1,2], [3,4], [5]]）
function chunk<T>(array: T[], size: number): T[][] {
  // 1. 必要な分割数を計算
  // 例：配列長さ545、サイズ100の場合
  // Math.ceil(545 / 100) = Math.ceil(5.45) = 6
  // Math.ceilは小数点以下を切り上げる関数
  const chunksNeeded = Math.ceil(array.length / size);

  // 2. Array.fromで新しい配列を作成
  // Array.fromは、反復可能なオブジェクトから新しい配列を生成するメソッド
  return Array.from(
    // 第1引数: 指定した長さ(chunksNeeded)を持つオブジェクト
    // 例：{ length: 6 } → 6個の要素を持つ配列を作る
    { length: chunksNeeded },

    // 第2引数: 配列の各要素を生成する関数
    // _: 使用しない引数（慣習的にアンダースコアで表現）
    // index: 現在の配列のインデックス（0から始まる）
    (_, index) => {
      // 各チャンクの開始位置を計算
      // 例：size = 100の場合
      // index = 0 → start = 0   （1個目のチャンク）
      // index = 1 → start = 100 （2個目のチャンク）
      // index = 2 → start = 200 （3個目のチャンク）
      const start = index * size;

      // 各チャンクの終了位置を計算
      // 例：size = 100の場合
      // index = 0 → end = 100   （1-100番目）
      // index = 1 → end = 200   （101-200番目）
      // index = 2 → end = 300   （201-300番目）
      const end = start + size;

      // array.slice(start, end)について：
      // ・配列の一部を切り出すメソッド
      // ・startインデックスから、end-1インデックスまでの要素を取得
      // ・元の配列は変更せず、新しい配列を返す
      //
      // 例：array = [1,2,3,4,5]の場合
      // array.slice(0, 2) → [1,2]    （インデックス0から1まで）
      // array.slice(2, 4) → [3,4]    （インデックス2から3まで）
      // array.slice(4, 5) → [5]      （インデックス4のみ）
      //
      // 注：endが配列の長さを超える場合は、自動的に配列の最後までを返す
      // 例：array.slice(4, 100) → [5]
      return array.slice(start, end);
    }
  );
}

// 使用例
// 1から1550までの連番配列を作成
const array1 = Array.from({ length: 1550 }, (_, i) => i + 1);
// array1 = [1, 2, 3, ..., 1549, 1550]

const result = chunk(array1, 100);
console.log(result);

// result は以下のような配列の配列になります：
[
  // チャンク1: インデックス0（1-100番目）
  // [1, 2, 3, ..., 99, 100],

  // // チャンク2: インデックス1（101-200番目）
  // [101, 102, 103, ..., 199, 200],

  // // チャンク3: インデックス2（201-300番目）
  // [201, 202, 203, ..., 299, 300],

  // // チャンク4: インデックス3（301-400番目）
  // [301, 302, 303, ..., 399, 400],

  // // チャンク5: インデックス4（401-500番目）
  // [401, 402, 403, ..., 499, 500],

  // // チャンク6: インデックス5（501-600番目）
  // [501, 502, 503, ..., 599, 600],

  // // チャンク7: インデックス6（601-700番目）
  // [601, 602, 603, ..., 699, 700],

  // // チャンク8: インデックス7（701-800番目）
  // [701, 702, 703, ..., 799, 800],

  // // チャンク9: インデックス8（801-900番目）
  // [801, 802, 803, ..., 899, 900],

  // // チャンク10: インデックス9（901-1000番目）
  // [901, 902, 903, ..., 999, 1000],

  // // チャンク11: インデックス10（1001-1100番目）
  // [1001, 1002, 1003, ..., 1099, 1100],

  // // チャンク12: インデックス11（1101-1200番目）
  // [1101, 1102, 1103, ..., 1199, 1200],

  // // チャンク13: インデックス12（1201-1300番目）
  // [1201, 1202, 1203, ..., 1299, 1300],

  // // チャンク14: インデックス13（1301-1400番目）
  // [1301, 1302, 1303, ..., 1399, 1400],

  // // チャンク15: インデックス14（1401-1500番目）
  // [1401, 1402, 1403, ..., 1499, 1500],

  // // チャンク16: インデックス15（1501-1550番目）
  // [1501, 1502, 1503, ..., 1549, 1550]  // 最後のチャンクは50個
]